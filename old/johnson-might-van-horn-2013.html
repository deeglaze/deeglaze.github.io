<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Optimizing Abstract Abstract Machines</title>
    <link rel="stylesheet" type="text/css" href="ianj.css" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  </head>

  <div id="publication">
    <h3>Optimizing Abstract Abstract Machines</h3>
    <span>J. Ian Johnson, Matt Might and David Van Horn</span><br />
    <span
      ><a href="oaam-draft.pdf">Draft</a>, <a href="http://arxiv.org/abs/1211.3722">arXiv</a>,
      <a href="https://github.com/dvanhorn/oaam">Implementation</a></span
    >
    <p>
      Abstracting abstract machines has been proposed as a lightweight approach to designing sound and computable program analyses. The approach
      derives abstract interpreters from existing machine semantics and has been applied to a variety of languages with features widely considered
      difficult to analyze. Although sound analyzers are straightforward to build under this approach, they are also prohibitively inefficient.
    </p>
    <p>
      This article contributes a step-by-step process for going from a naive analyzer derived under the abstracting abstract machine approach to an
      efficient program analyzer. The end result of the process is a two to three order-of-magnitude improvement over the systematically derived
      analyzer, making it competitive with hand-optimized implementations that compute fundamentally less precise results.
    </p>
  </div>
</html>
